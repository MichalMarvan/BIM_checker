<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDS-IFC Valid√°tor</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .page-container {
            max-width: 1900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.1em; opacity: 0.95; }

        .back-home-btn {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .back-home-btn:hover {
            background: white;
            color: #667eea;
        }

        .upload-section {
            background: #f8f9fa;
            padding: 40px;
            border-bottom: 2px solid #e9ecef;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-box:hover {
            border-color: #764ba2;
            background: #f8f9ff;
        }

        .upload-box.has-files {
            border-color: #28a745;
            border-style: solid;
        }

        .upload-icon {
            font-size: 3em;
            color: #667eea;
            margin-bottom: 15px;
        }

        .upload-box.has-files .upload-icon {
            color: #28a745;
        }

        .upload-box h3 {
            font-size: 1.2em;
            color: #495057;
            margin-bottom: 10px;
        }

        .upload-box p {
            color: #6c757d;
            font-size: 0.9em;
        }

        .file-input {
            display: none;
        }

        .file-list {
            margin-top: 15px;
            text-align: left;
        }

        .file-item {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        .file-item-name {
            color: #495057;
            font-weight: 600;
        }

        .file-remove {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .file-remove:hover {
            background: #c82333;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-primary:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .validate-button-container {
            text-align: center;
            padding-top: 20px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-section {
            padding: 40px;
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .stat-card.pass {
            border-color: #28a745;
        }

        .stat-card.fail {
            border-color: #dc3545;
        }

        .stat-card.warning {
            border-color: #ffc107;
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-card.pass .stat-number {
            color: #28a745;
        }

        .stat-card.fail .stat-number {
            color: #dc3545;
        }

        .stat-card.warning .stat-number {
            color: #ffc107;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filters-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr auto;
            gap: 15px;
            align-items: center;
        }

        .filter-input {
            padding: 10px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1em;
        }

        .filter-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .specification-result {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .specification-result.collapsed .spec-details {
            display: none;
        }

        .specification-result.pass {
            border-color: #28a745;
        }

        .specification-result.fail {
            border-color: #dc3545;
        }

        .spec-header {
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .spec-header:hover {
            background: #e9ecef;
        }

        .spec-title {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .expand-icon {
            transition: transform 0.3s;
            font-size: 1.2em;
            color: #6c757d;
        }

        .specification-result.collapsed .expand-icon {
            transform: rotate(-90deg);
        }

        .spec-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #2d3748;
        }

        .spec-status-badge {
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            text-transform: uppercase;
        }

        .spec-status-badge.pass {
            background: #d4edda;
            color: #155724;
        }

        .spec-status-badge.fail {
            background: #f8d7da;
            color: #721c24;
        }

        .spec-stats {
            display: flex;
            gap: 20px;
            font-size: 0.9em;
            color: #6c757d;
        }

        .spec-details {
            padding: 20px;
            border-top: 2px solid #e9ecef;
        }

        .entity-result {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #e9ecef;
        }

        .entity-result.pass {
            border-left-color: #28a745;
        }

        .entity-result.fail {
            border-left-color: #dc3545;
        }

        .entity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .entity-info {
            flex: 1;
        }

        .entity-type {
            font-weight: 600;
            color: #667eea;
            font-size: 0.95em;
        }

        .entity-name {
            color: #495057;
            font-size: 0.9em;
            margin-top: 3px;
        }

        .entity-guid {
            font-family: 'Courier New', monospace;
            color: #6c757d;
            font-size: 0.85em;
            margin-top: 3px;
        }

        .entity-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .entity-status.pass {
            background: #d4edda;
            color: #155724;
        }

        .entity-status.fail {
            background: #f8d7da;
            color: #721c24;
        }

        .validation-details {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #dee2e6;
        }

        .validation-item {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.9em;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .validation-item.pass {
            background: #d4edda;
        }

        .validation-item.fail {
            background: #f8d7da;
        }

        .validation-icon {
            font-size: 1.1em;
            min-width: 20px;
        }

        .validation-message {
            flex: 1;
        }

        .validation-label {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .validation-value {
            color: #6c757d;
            font-size: 0.9em;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px solid #f5c6cb;
            display: none;
        }

        @media (max-width: 768px) {
            .upload-grid {
                grid-template-columns: 1fr;
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .results-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <div class="header">
            <a href="../index.html" class="back-home-btn">‚Üê Dom≈Ø</a>
            <h1>‚úÖ IDS-IFC Valid√°tor</h1>
            <p>Validujte IFC soubory podle IDS specifikac√≠</p>
        </div>

        <div class="upload-section">
            <div class="upload-grid">
                <div class="upload-box" id="ifcUploadBox">
                    <div class="upload-icon">üì¶</div>
                    <h3>IFC Soubory</h3>
                    <p>P≈ôet√°hnƒõte nebo vyberte IFC soubory k validaci</p>
                    <input type="file" id="ifcInput" class="file-input" accept=".ifc" multiple>
                    <div class="file-list" id="ifcFileList"></div>
                </div>

                <div class="upload-box" id="idsUploadBox">
                    <div class="upload-icon">üìã</div>
                    <h3>IDS Specifikace</h3>
                    <p>P≈ôet√°hnƒõte nebo vyberte IDS soubory</p>
                    <input type="file" id="idsInput" class="file-input" accept=".ids,.xml" multiple>
                    <div class="file-list" id="idsFileList"></div>
                </div>
            </div>

            <div class="error-message" id="errorMessage"></div>

            <div class="validate-button-container">
                <button class="btn btn-primary" id="validateBtn" disabled>
                    üîç Spustit validaci
                </button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div id="loadingText">Prob√≠h√° validace...</div>
            <div id="progressText" style="margin-top: 15px; font-size: 1.1em; font-weight: 600; color: #667eea;"></div>
            <div id="currentFile" style="margin-top: 10px; color: #6c757d; font-size: 0.9em;"></div>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-header">
                <h2>üìä V√Ωsledky validace</h2>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-success" id="exportBtn">üì• Export XLSX</button>
                    <button class="btn btn-secondary" id="expandAllBtn">üìñ Rozbalit v≈°e</button>
                    <button class="btn btn-secondary" id="collapseAllBtn">üìï Sbalit v≈°e</button>
                    <button class="btn btn-secondary" id="newValidationBtn">üîÑ Nov√° validace</button>
                </div>
            </div>

            <div class="results-stats" id="resultsStats"></div>

            <div class="filters-section">
                <div class="filters-grid">
                    <input type="text" id="searchFilter" class="filter-input" placeholder="üîç Hledat...">
                    <select id="statusFilter" class="filter-input">
                        <option value="">V≈°echny stavy</option>
                        <option value="pass">‚úÖ Splnƒõno</option>
                        <option value="fail">‚ùå Nesplnƒõno</option>
                    </select>
                    <select id="specFilter" class="filter-input">
                        <option value="">V≈°echny specifikace</option>
                    </select>
                    <button class="btn btn-secondary" id="clearFiltersBtn">Vymazat filtry</button>
                </div>
            </div>

            <div id="resultsList"></div>
        </div>
    </div>

    <script>
        let ifcFiles = [];
        let idsFiles = [];
        let validationResults = null;
        let allEntities = [];

        // Upload handlers
        document.getElementById('ifcUploadBox').addEventListener('click', () => {
            document.getElementById('ifcInput').click();
        });

        document.getElementById('idsUploadBox').addEventListener('click', () => {
            document.getElementById('idsInput').click();
        });

        document.getElementById('ifcInput').addEventListener('change', (e) => {
            handleIFCFiles(Array.from(e.target.files));
        });

        document.getElementById('idsInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleIDSFiles(Array.from(e.target.files));
            }
        });

        // Drag and drop for IFC
        setupDragDrop('ifcUploadBox', 'ifcInput', handleIFCFiles);
        setupDragDrop('idsUploadBox', 'idsInput', handleIDSFiles);

        function setupDragDrop(boxId, inputId, handler) {
            const box = document.getElementById(boxId);

            box.addEventListener('dragover', (e) => {
                e.preventDefault();
                box.style.borderColor = '#764ba2';
            });

            box.addEventListener('dragleave', () => {
                box.style.borderColor = '#667eea';
            });

            box.addEventListener('drop', (e) => {
                e.preventDefault();
                box.style.borderColor = '#667eea';
                const files = Array.from(e.dataTransfer.files);
                handler(files);
            });
        }

        function handleIFCFiles(files) {
            const ifcFiles_filtered = files.filter(f => f.name.endsWith('.ifc'));

            if (ifcFiles_filtered.length === 0) {
                showError('Pouze .ifc soubory jsou podporov√°ny');
                return;
            }

            ifcFiles = ifcFiles_filtered;
            updateIFCFileList();
            updateValidateButton();
        }

        function handleIDSFiles(files) {
            const idsFiles_filtered = files.filter(f => f.name.match(/\.(ids|xml)$/i));

            if (idsFiles_filtered.length === 0) {
                showError('Pouze .ids nebo .xml soubory jsou podporov√°ny');
                return;
            }

            let processed = 0;
            const newIdsFiles = [];

            idsFiles_filtered.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const idsData = parseIDS(e.target.result, file.name);
                        newIdsFiles.push({
                            fileName: file.name,
                            data: idsData
                        });
                        processed++;

                        if (processed === idsFiles_filtered.length) {
                            idsFiles.push(...newIdsFiles);
                            updateIDSFileList();
                            updateValidateButton();
                        }
                    } catch (error) {
                        showError('Chyba p≈ôi naƒç√≠t√°n√≠ IDS souboru ' + file.name + ': ' + error.message);
                    }
                };
                reader.readAsText(file);
            });
        }

        function updateIFCFileList() {
            const list = document.getElementById('ifcFileList');
            const box = document.getElementById('ifcUploadBox');

            if (ifcFiles.length > 0) {
                box.classList.add('has-files');
                list.innerHTML = ifcFiles.map((file, idx) => `
                    <div class="file-item">
                        <span class="file-item-name">${file.name}</span>
                        <button class="file-remove" onclick="removeIFCFile(${idx})">√ó</button>
                    </div>
                `).join('');
            } else {
                box.classList.remove('has-files');
                list.innerHTML = '';
            }
        }

        function updateIDSFileList() {
            const list = document.getElementById('idsFileList');
            const box = document.getElementById('idsUploadBox');

            if (idsFiles.length > 0) {
                box.classList.add('has-files');
                list.innerHTML = idsFiles.map((file, idx) => `
                    <div class="file-item">
                        <span class="file-item-name">${file.fileName}</span>
                        <button class="file-remove" onclick="removeIDSFile(${idx})">√ó</button>
                    </div>
                `).join('');
            } else {
                box.classList.remove('has-files');
                list.innerHTML = '';
            }
        }

        function removeIFCFile(index) {
            ifcFiles.splice(index, 1);
            updateIFCFileList();
            updateValidateButton();
        }

        function removeIDSFile(index) {
            idsFiles.splice(index, 1);
            updateIDSFileList();
            updateValidateButton();
        }

        function updateValidateButton() {
            const btn = document.getElementById('validateBtn');
            btn.disabled = !(ifcFiles.length > 0 && idsFiles.length > 0);
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 5000);
        }

        // IDS Parsing
        function parseIDS(xmlString, fileName) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            const parserError = xmlDoc.querySelector('parsererror');
            if (parserError) {
                throw new Error('Neplatn√Ω XML soubor');
            }

            return {
                info: extractIDSInfo(xmlDoc),
                specifications: extractSpecifications(xmlDoc)
            };
        }

        function extractIDSInfo(xmlDoc) {
            const info = {};
            const infoElement = xmlDoc.querySelector('info');

            if (infoElement) {
                info.title = infoElement.querySelector('title')?.textContent || 'Bez n√°zvu';
                info.version = infoElement.querySelector('version')?.textContent || '';
            }

            return info;
        }

        function extractSpecifications(xmlDoc) {
            const specifications = [];
            const specElements = xmlDoc.querySelectorAll('specification');

            specElements.forEach((spec, index) => {
                const specification = {
                    name: spec.getAttribute('name') || `Specifikace ${index + 1}`,
                    ifcVersion: spec.getAttribute('ifcVersion') || 'IFC4',
                    applicability: extractFacets(spec.querySelector('applicability')),
                    requirements: extractFacets(spec.querySelector('requirements'))
                };
                specifications.push(specification);
            });

            return specifications;
        }

        function extractFacets(facetsElement) {
            if (!facetsElement) return [];

            const facets = [];
            const facetTypes = ['entity', 'partOf', 'classification', 'attribute', 'property', 'material'];

            facetTypes.forEach(type => {
                const elements = facetsElement.querySelectorAll(type);
                elements.forEach(elem => {
                    facets.push(extractFacet(elem, type));
                });
            });

            return facets;
        }

        function extractFacet(element, type) {
            const facet = { type };

            const nameElem = element.querySelector('name, baseName');
            if (nameElem) {
                facet.name = extractValue(nameElem);
            }

            const valueElem = element.querySelector('value');
            if (valueElem) {
                facet.value = extractValue(valueElem);
            }

            if (type === 'property') {
                const propSetElem = element.querySelector('propertySet, propertyset');
                if (propSetElem) {
                    facet.propertySet = extractValue(propSetElem);
                }
            }

            if (type === 'partOf') {
                const relationElem = element.querySelector('relation');
                if (relationElem) {
                    facet.relation = extractValue(relationElem);
                }
            }

            if (type === 'classification') {
                const systemElem = element.querySelector('system');
                if (systemElem) {
                    facet.system = extractValue(systemElem);
                }
            }

            const predefinedElem = element.querySelector('predefinedType');
            if (predefinedElem) {
                facet.predefinedType = extractValue(predefinedElem);
            }

            facet.cardinality = element.getAttribute('cardinality') || 'required';

            return facet;
        }

        function extractValue(element) {
            const simpleValue = element.querySelector('simpleValue');
            if (simpleValue) {
                return { type: 'simple', value: simpleValue.textContent };
            }

            const restriction = element.querySelector('restriction');
            if (restriction) {
                return extractRestriction(restriction);
            }

            return { type: 'simple', value: element.textContent };
        }

        function extractRestriction(restriction) {
            const result = { type: 'restriction' };

            let pattern = restriction.querySelector('pattern');
            if (!pattern) {
                pattern = restriction.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'pattern')[0];
            }
            if (pattern) {
                result.pattern = pattern.getAttribute('value') || pattern.textContent;
                result.isRegex = true;
            }

            const options = restriction.querySelectorAll('option');
            if (options.length > 0) {
                result.options = Array.from(options).map(opt => opt.textContent);
            }

            return result;
        }

        // Validation
        document.getElementById('validateBtn').addEventListener('click', performValidation);

        async function performValidation() {
            document.getElementById('loading').style.display = 'block';
            document.querySelector('.upload-section').style.display = 'none';

            const progressText = document.getElementById('progressText');
            const currentFile = document.getElementById('currentFile');
            const loadingText = document.getElementById('loadingText');

            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                validationResults = [];

                // Parse all IFC files first
                loadingText.textContent = 'Naƒç√≠t√°n√≠ IFC soubor≈Ø...';
                const parsedIfcFiles = [];
                const totalIfc = ifcFiles.length;

                for (let i = 0; i < ifcFiles.length; i++) {
                    const file = ifcFiles[i];
                    progressText.textContent = `Naƒç√≠t√°n√≠ IFC: ${i + 1} / ${totalIfc}`;
                    currentFile.textContent = `üì¶ ${file.name}`;
                    await new Promise(resolve => setTimeout(resolve, 50));

                    const content = await readFileAsText(file);
                    const entities = parseIFCFile(content, file.name);
                    parsedIfcFiles.push({
                        fileName: file.name,
                        entities: entities
                    });
                }

                // For each IDS file, validate against all IFC files
                loadingText.textContent = 'Prob√≠h√° validace...';
                const totalIds = idsFiles.length;
                let idsCount = 0;

                for (let idsFile of idsFiles) {
                    idsCount++;
                    const idsResult = {
                        idsFileName: idsFile.fileName,
                        idsTitle: idsFile.data.info.title || idsFile.fileName,
                        ifcResults: []
                    };

                    // Validate each IFC file against this IDS
                    for (let i = 0; i < parsedIfcFiles.length; i++) {
                        const ifcFile = parsedIfcFiles[i];
                        progressText.textContent = `IDS ${idsCount}/${totalIds} ‚Üí IFC ${i + 1}/${totalIfc}`;
                        currentFile.textContent = `üìã ${idsFile.fileName} ‚úì üì¶ ${ifcFile.fileName}`;
                        await new Promise(resolve => setTimeout(resolve, 50));

                        const ifcResult = {
                            ifcFileName: ifcFile.fileName,
                            specificationResults: validateEntitiesAgainstIDS(ifcFile.entities, idsFile.data.specifications)
                        };
                        idsResult.ifcResults.push(ifcResult);
                    }

                    validationResults.push(idsResult);
                }

                // Display results
                loadingText.textContent = 'Generov√°n√≠ v√Ωsledk≈Ø...';
                progressText.textContent = '';
                currentFile.textContent = '';
                displayResults();

                document.getElementById('loading').style.display = 'none';
                document.getElementById('resultsSection').style.display = 'block';
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                showError('Chyba p≈ôi validaci: ' + error.message);
                document.querySelector('.upload-section').style.display = 'block';
            }
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        // IFC Parsing (simplified version)
        function parseIFCFile(content, fileName) {
            const entities = [];
            const lines = content.split('\n');
            const entityMap = new Map();
            const propertySetMap = new Map();
            const relDefinesMap = new Map();

            // Collect entities
            for (let line of lines) {
                line = line.trim();
                if (!line.startsWith('#')) continue;
                const match = line.match(/^#(\d+)\s*=\s*([A-Z0-9_]+)\((.*)\);?$/i);
                if (!match) continue;
                const [, id, entityType, params] = match;
                entityMap.set(id, { id, type: entityType, params });
            }

            // Parse property sets
            for (let [id, entity] of entityMap) {
                if (entity.type === 'IFCPROPERTYSET') {
                    const props = parsePropertySet(entity.params, entityMap);
                    propertySetMap.set(id, props);
                } else if (entity.type === 'IFCRELDEFINESBYPROPERTIES') {
                    const rel = parseRelDefines(entity.params);
                    relDefinesMap.set(id, rel);
                }
            }

            // Build entities list
            for (let [id, entity] of entityMap) {
                if (entity.type.startsWith('IFC') &&
                    !entity.type.includes('REL') &&
                    !entity.type.includes('PROPERTY') &&
                    entity.params.includes("'")) {

                    const guid = extractGUID(entity.params);
                    const name = extractName(entity.params);

                    if (guid) {
                        const propertySets = {};

                        for (let [relId, rel] of relDefinesMap) {
                            if (rel.relatedObjects && rel.relatedObjects.includes(id)) {
                                const psetId = rel.relatingPropertyDefinition;
                                if (propertySetMap.has(psetId)) {
                                    const pset = propertySetMap.get(psetId);
                                    propertySets[pset.name] = pset.properties;
                                }
                            }
                        }

                        entities.push({
                            guid,
                            entity: entity.type,
                            name: name || '-',
                            propertySets,
                            fileName,
                            attributes: {
                                Name: name || '-',
                                GlobalId: guid
                            }
                        });
                    }
                }
            }

            return entities;
        }

        function extractGUID(params) {
            const match = params.match(/'([^']+)'/);
            return match ? match[1] : null;
        }

        function extractName(params) {
            const matches = params.match(/'([^']*)'/g);
            const rawName = matches && matches.length > 1 ? matches[1].replace(/'/g, '') : null;
            return rawName ? decodeIFCString(rawName) : null;
        }

        function decodeIFCString(str) {
            if (!str) return str;
            str = str.replace(/\\X\\([0-9A-F]{2})/gi, (m, hex) => String.fromCharCode(parseInt(hex, 16)));
            str = str.replace(/\\X2\\([0-9A-F]+)\\X0\\/gi, (m, hex) => String.fromCharCode(parseInt(hex, 16)));
            return str;
        }

        function parsePropertySet(params, entityMap) {
            const parts = splitParams(params);
            const rawName = parts[2] ? parts[2].replace(/'/g, '') : 'Unknown';
            const name = decodeIFCString(rawName);
            const properties = {};

            if (parts.length > 4) {
                const propIds = parts[4].match(/#\d+/g);
                if (propIds) {
                    for (let propId of propIds) {
                        const id = propId.substring(1);
                        const propEntity = entityMap.get(id);
                        if (propEntity && propEntity.type === 'IFCPROPERTYSINGLEVALUE') {
                            const prop = parseProperty(propEntity.params);
                            if (prop) properties[prop.name] = prop.value;
                        }
                    }
                }
            }

            return { name, properties };
        }

        function parseProperty(params) {
            const parts = splitParams(params);
            if (parts.length < 3) return null;
            const rawName = parts[0].replace(/'/g, '');
            const name = decodeIFCString(rawName);
            let value = parts[2] || '';
            const valueMatch = value.match(/IFC[A-Z]+\s*\(\s*'([^']*)'\s*\)/i);
            if (valueMatch) {
                value = decodeIFCString(valueMatch[1]);
            }
            return { name, value };
        }

        function parseRelDefines(params) {
            const parts = splitParams(params);
            const relatedObjects = parts[4] ? parts[4].match(/#\d+/g)?.map(r => r.substring(1)) : [];
            const relatingMatch = parts[5] ? parts[5].match(/#(\d+)/) : null;
            return {
                relatedObjects,
                relatingPropertyDefinition: relatingMatch ? relatingMatch[1] : null
            };
        }

        function splitParams(params) {
            const parts = [];
            let current = '';
            let depth = 0;
            let inString = false;

            for (let char of params) {
                if (char === "'" && (current.length === 0 || current[current.length - 1] !== '\\')) {
                    inString = !inString;
                }
                if (!inString) {
                    if (char === '(') depth++;
                    else if (char === ')') depth--;
                    else if (char === ',' && depth === 0) {
                        parts.push(current.trim());
                        current = '';
                        continue;
                    }
                }
                current += char;
            }
            if (current) parts.push(current.trim());
            return parts;
        }

        // Validation Logic
        function validateEntitiesAgainstIDS(entities, specifications) {
            const results = [];

            for (let spec of specifications) {
                const specResult = {
                    specification: spec.name,
                    status: 'pass',
                    passCount: 0,
                    failCount: 0,
                    entityResults: []
                };

                // Find applicable entities
                const applicableEntities = filterEntitiesByApplicability(entities, spec.applicability);

                // Validate each applicable entity against requirements
                for (let entity of applicableEntities) {
                    const entityResult = validateEntityAgainstRequirements(entity, spec.requirements, spec.name);
                    specResult.entityResults.push(entityResult);

                    if (entityResult.status === 'pass') {
                        specResult.passCount++;
                    } else {
                        specResult.failCount++;
                        specResult.status = 'fail';
                    }
                }

                // Only add specification if it has entities
                if (specResult.entityResults.length > 0) {
                    results.push(specResult);
                }
            }

            return results;
        }

        function filterEntitiesByApplicability(entities, applicability) {
            if (!applicability || applicability.length === 0) {
                return entities;
            }

            return entities.filter(entity => {
                for (let facet of applicability) {
                    if (!checkFacetMatch(entity, facet)) {
                        return false;
                    }
                }
                return true;
            });
        }

        function validateEntityAgainstRequirements(entity, requirements, specName) {
            const result = {
                entity: entity.entity,
                name: entity.name,
                guid: entity.guid,
                fileName: entity.fileName,
                specification: specName,
                status: 'pass',
                validations: []
            };

            for (let facet of requirements) {
                const validation = checkRequirementFacet(entity, facet);
                result.validations.push(validation);

                if (validation.status === 'fail') {
                    result.status = 'fail';
                }
            }

            return result;
        }

        function checkFacetMatch(entity, facet) {
            if (facet.type === 'entity') {
                return checkEntityFacet(entity, facet);
            } else if (facet.type === 'property') {
                return checkPropertyFacet(entity, facet, true);
            } else if (facet.type === 'attribute') {
                return checkAttributeFacet(entity, facet, true);
            }
            return true;
        }

        function checkRequirementFacet(entity, facet) {
            const validation = {
                type: facet.type,
                status: 'fail',
                message: '',
                details: ''
            };

            if (facet.type === 'property') {
                return checkPropertyFacet(entity, facet, false);
            } else if (facet.type === 'attribute') {
                return checkAttributeFacet(entity, facet, false);
            } else if (facet.type === 'material') {
                validation.message = 'Material facet';
                validation.details = 'Material validation not fully implemented';
                validation.status = 'pass'; // Simplified
            } else if (facet.type === 'classification') {
                validation.message = 'Classification facet';
                validation.details = 'Classification validation not fully implemented';
                validation.status = 'pass'; // Simplified
            }

            return validation;
        }

        function checkEntityFacet(entity, facet) {
            if (!facet.name) return true;

            if (facet.name.type === 'simple') {
                return entity.entity === facet.name.value;
            } else if (facet.name.type === 'restriction' && facet.name.isRegex) {
                const regex = new RegExp(facet.name.pattern);
                return regex.test(entity.entity);
            }

            return true;
        }

        function checkPropertyFacet(entity, facet, isApplicability) {
            const validation = {
                type: 'property',
                status: 'fail',
                message: '',
                details: ''
            };

            const psetName = facet.propertySet?.value || facet.propertySet?.type === 'simple' && facet.propertySet.value;
            const propName = facet.name?.value || facet.name?.type === 'simple' && facet.name.value;

            if (!psetName || !propName) {
                validation.message = 'Property specification incomplete';
                return isApplicability ? false : validation;
            }

            validation.message = `${psetName}.${propName}`;

            const pset = entity.propertySets[psetName];
            if (!pset) {
                validation.details = `PropertySet "${psetName}" not found`;
                return isApplicability ? false : validation;
            }

            const propValue = pset[propName];
            if (propValue === undefined) {
                validation.details = `Property "${propName}" not found in ${psetName}`;
                return isApplicability ? false : validation;
            }

            // Check value if specified
            if (facet.value) {
                if (facet.value.type === 'simple') {
                    if (String(propValue) !== String(facet.value.value)) {
                        validation.details = `Expected "${facet.value.value}", got "${propValue}"`;
                        return isApplicability ? false : validation;
                    }
                } else if (facet.value.type === 'restriction') {
                    if (facet.value.options) {
                        if (!facet.value.options.includes(String(propValue))) {
                            validation.details = `Value "${propValue}" not in allowed options: ${facet.value.options.join(', ')}`;
                            return isApplicability ? false : validation;
                        }
                    } else if (facet.value.isRegex) {
                        const regex = new RegExp(facet.value.pattern);
                        if (!regex.test(String(propValue))) {
                            validation.details = `Value "${propValue}" doesn't match pattern: ${facet.value.pattern}`;
                            return isApplicability ? false : validation;
                        }
                    }
                }
            }

            validation.status = 'pass';
            validation.details = `Value: "${propValue}"`;
            return isApplicability ? true : validation;
        }

        function checkAttributeFacet(entity, facet, isApplicability) {
            const validation = {
                type: 'attribute',
                status: 'fail',
                message: '',
                details: ''
            };

            const attrName = facet.name?.value || facet.name?.type === 'simple' && facet.name.value;
            if (!attrName) {
                validation.message = 'Attribute specification incomplete';
                return isApplicability ? false : validation;
            }

            validation.message = `Attribute: ${attrName}`;

            const attrValue = entity.attributes[attrName];
            if (attrValue === undefined) {
                validation.details = `Attribute "${attrName}" not found`;
                return isApplicability ? false : validation;
            }

            // Check value if specified
            if (facet.value) {
                if (facet.value.type === 'simple') {
                    if (String(attrValue) !== String(facet.value.value)) {
                        validation.details = `Expected "${facet.value.value}", got "${attrValue}"`;
                        return isApplicability ? false : validation;
                    }
                } else if (facet.value.type === 'restriction' && facet.value.isRegex) {
                    const regex = new RegExp(facet.value.pattern);
                    if (!regex.test(String(attrValue))) {
                        validation.details = `Value "${attrValue}" doesn't match pattern: ${facet.value.pattern}`;
                        return isApplicability ? false : validation;
                    }
                }
            }

            validation.status = 'pass';
            validation.details = `Value: "${attrValue}"`;
            return isApplicability ? true : validation;
        }

        // Display Results
        function displayResults() {
            displayStats();
            populateSpecFilter();
            displaySpecificationResults();
        }

        function displayStats() {
            const statsContainer = document.getElementById('resultsStats');

            let totalPass = 0;
            let totalFail = 0;
            let totalValidations = 0;

            // Count across all IDS and IFC combinations
            for (let idsResult of validationResults) {
                for (let ifcResult of idsResult.ifcResults) {
                    for (let specResult of ifcResult.specificationResults) {
                        totalPass += specResult.passCount;
                        totalFail += specResult.failCount;
                    }
                }
                totalValidations++;
            }

            const totalEntities = totalPass + totalFail;

            statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${totalValidations}</div>
                    <div class="stat-label">IDS Soubor≈Ø</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalEntities}</div>
                    <div class="stat-label">Celkem validac√≠</div>
                </div>
                <div class="stat-card pass">
                    <div class="stat-number">${totalPass}</div>
                    <div class="stat-label">‚úÖ Splnƒõno</div>
                </div>
                <div class="stat-card fail">
                    <div class="stat-number">${totalFail}</div>
                    <div class="stat-label">‚ùå Nesplnƒõno</div>
                </div>
            `;
        }

        function populateSpecFilter() {
            const select = document.getElementById('specFilter');
            select.innerHTML = '<option value="">V≈°echny IDS soubory</option>';

            for (let idsResult of validationResults) {
                const option = document.createElement('option');
                option.value = idsResult.idsFileName;
                option.textContent = idsResult.idsTitle;
                select.appendChild(option);
            }
        }

        function displaySpecificationResults() {
            const container = document.getElementById('resultsList');
            container.innerHTML = '';

            for (let idsResult of validationResults) {
                const idsDiv = createIDSResultElement(idsResult);
                if (idsDiv) {
                    container.appendChild(idsDiv);
                }
            }

            // Add event listeners for filtering
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            document.getElementById('statusFilter').addEventListener('change', applyFilters);
            document.getElementById('specFilter').addEventListener('change', applyFilters);
            document.getElementById('clearFiltersBtn').addEventListener('click', clearFilters);
        }

        function createIDSResultElement(idsResult) {
            // Calculate stats for this IDS and collect non-empty IFC results
            let totalPass = 0;
            let totalFail = 0;
            const nonEmptyIfcResults = [];

            for (let ifcResult of idsResult.ifcResults) {
                // Check if this IFC has any specifications with results
                if (ifcResult.specificationResults && ifcResult.specificationResults.length > 0) {
                    nonEmptyIfcResults.push(ifcResult);
                    for (let specResult of ifcResult.specificationResults) {
                        totalPass += specResult.passCount;
                        totalFail += specResult.failCount;
                    }
                }
            }

            // Skip this IDS if no IFC files have results
            if (nonEmptyIfcResults.length === 0) {
                return null;
            }

            const status = totalFail === 0 ? 'pass' : 'fail';

            const div = document.createElement('div');
            div.className = `specification-result ${status} collapsed`;
            div.dataset.idsfile = idsResult.idsFileName;
            div.dataset.status = status;

            const headerDiv = document.createElement('div');
            headerDiv.className = 'spec-header';
            headerDiv.onclick = () => toggleSpecification(div);

            headerDiv.innerHTML = `
                <div class="spec-title">
                    <span class="expand-icon">‚ñº</span>
                    <span class="spec-name">üìã ${idsResult.idsTitle}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div class="spec-stats">
                        <span>‚úÖ ${totalPass}</span>
                        <span>‚ùå ${totalFail}</span>
                    </div>
                    <span class="spec-status-badge ${status}">
                        ${status === 'pass' ? '‚úÖ Splnƒõno' : '‚ùå Nesplnƒõno'}
                    </span>
                </div>
            `;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'spec-details';

            // For each non-empty IFC file result
            for (let ifcResult of nonEmptyIfcResults) {
                const ifcDiv = createIFCResultElement(ifcResult);
                if (ifcDiv) {
                    detailsDiv.appendChild(ifcDiv);
                }
            }

            div.appendChild(headerDiv);
            div.appendChild(detailsDiv);

            return div;
        }

        function createIFCResultElement(ifcResult) {
            // Skip if no specifications with results
            if (!ifcResult.specificationResults || ifcResult.specificationResults.length === 0) {
                return null;
            }

            // Calculate stats for this IFC
            let totalPass = 0;
            let totalFail = 0;
            for (let specResult of ifcResult.specificationResults) {
                totalPass += specResult.passCount;
                totalFail += specResult.failCount;
            }
            const status = totalFail === 0 ? 'pass' : 'fail';

            const div = document.createElement('div');
            div.style.marginBottom = '15px';

            const header = document.createElement('div');
            header.style.cssText = 'background: #e9ecef; padding: 12px 15px; border-radius: 6px; font-weight: 600; color: #495057; margin-bottom: 10px; cursor: pointer;';
            header.onclick = () => {
                const content = header.nextElementSibling;
                const icon = header.querySelector('.toggle-icon');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    icon.textContent = '‚ñº';
                } else {
                    content.style.display = 'none';
                    icon.textContent = '‚ñ∂';
                }
            };
            header.innerHTML = `
                <span class="toggle-icon">‚ñº</span>
                üì¶ ${ifcResult.ifcFileName}
                <span style="margin-left: 15px; font-size: 0.9em; color: #6c757d;">
                    ‚úÖ ${totalPass} | ‚ùå ${totalFail}
                </span>
            `;

            const content = document.createElement('div');
            content.style.paddingLeft = '20px';

            // For each specification in this IFC
            for (let specResult of ifcResult.specificationResults) {
                const specDiv = createSpecificationResultElement(specResult);
                content.appendChild(specDiv);
            }

            div.appendChild(header);
            div.appendChild(content);

            return div;
        }

        function createSpecificationResultElement(specResult) {
            const div = document.createElement('div');
            div.className = `specification-result ${specResult.status} collapsed`;
            div.dataset.specification = specResult.specification;
            div.dataset.status = specResult.status;
            div.style.marginBottom = '10px';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'spec-header';
            headerDiv.style.background = '#f8f9fa';
            headerDiv.onclick = () => toggleSpecification(div);

            headerDiv.innerHTML = `
                <div class="spec-title">
                    <span class="expand-icon">‚ñº</span>
                    <span class="spec-name">${specResult.specification}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div class="spec-stats">
                        <span>‚úÖ ${specResult.passCount}</span>
                        <span>‚ùå ${specResult.failCount}</span>
                    </div>
                    <span class="spec-status-badge ${specResult.status}">
                        ${specResult.status === 'pass' ? '‚úÖ OK' : '‚ùå FAIL'}
                    </span>
                </div>
            `;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'spec-details';

            for (let entityResult of specResult.entityResults) {
                const entityDiv = createEntityResultElement(entityResult);
                detailsDiv.appendChild(entityDiv);
            }

            div.appendChild(headerDiv);
            div.appendChild(detailsDiv);

            return div;
        }

        function createEntityResultElement(entityResult) {
            const div = document.createElement('div');
            div.className = `entity-result ${entityResult.status}`;
            div.dataset.entity = entityResult.entity;
            div.dataset.name = entityResult.name;
            div.dataset.guid = entityResult.guid;
            div.dataset.status = entityResult.status;

            let validationsHTML = '';
            if (entityResult.validations && entityResult.validations.length > 0) {
                validationsHTML = '<div class="validation-details">';
                for (let validation of entityResult.validations) {
                    const icon = validation.status === 'pass' ? '‚úÖ' : '‚ùå';
                    validationsHTML += `
                        <div class="validation-item ${validation.status}">
                            <span class="validation-icon">${icon}</span>
                            <div class="validation-message">
                                <div class="validation-label">${validation.message}</div>
                                <div class="validation-value">${validation.details}</div>
                            </div>
                        </div>
                    `;
                }
                validationsHTML += '</div>';
            }

            div.innerHTML = `
                <div class="entity-header">
                    <div class="entity-info">
                        <div class="entity-type">${entityResult.entity}</div>
                        <div class="entity-name">Name: ${entityResult.name}</div>
                        <div class="entity-guid">GUID: ${entityResult.guid}</div>
                        <div class="entity-name" style="font-size: 0.85em; color: #6c757d;">File: ${entityResult.fileName}</div>
                    </div>
                    <span class="entity-status ${entityResult.status}">
                        ${entityResult.status === 'pass' ? '‚úÖ OK' : '‚ùå FAIL'}
                    </span>
                </div>
                ${validationsHTML}
            `;

            return div;
        }

        function toggleSpecification(div) {
            div.classList.toggle('collapsed');
        }

        // Expand/Collapse All
        document.getElementById('expandAllBtn').addEventListener('click', expandAll);
        document.getElementById('collapseAllBtn').addEventListener('click', collapseAll);

        function expandAll() {
            // Rozbalit v≈°echny IDS sekce
            document.querySelectorAll('.specification-result').forEach(div => {
                div.classList.remove('collapsed');
            });

            // Rozbalit v≈°echny IFC sekce (inline toggle divs)
            document.querySelectorAll('.toggle-icon').forEach(icon => {
                const content = icon.parentElement.nextElementSibling;
                if (content && content.style.display === 'none') {
                    content.style.display = 'block';
                    icon.textContent = '‚ñº';
                }
            });
        }

        function collapseAll() {
            // Sbalit v≈°echny IDS sekce
            document.querySelectorAll('.specification-result').forEach(div => {
                div.classList.add('collapsed');
            });

            // Sbalit v≈°echny IFC sekce (inline toggle divs)
            document.querySelectorAll('.toggle-icon').forEach(icon => {
                const content = icon.parentElement.nextElementSibling;
                if (content && content.style.display !== 'none') {
                    content.style.display = 'none';
                    icon.textContent = '‚ñ∂';
                }
            });
        }

        // Filtering
        function applyFilters() {
            const searchText = document.getElementById('searchFilter').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const idsFileFilter = document.getElementById('specFilter').value;

            // Get all IDS result divs (top level)
            const idsResults = document.querySelectorAll('.specification-result[data-idsfile]');

            for (let idsDiv of idsResults) {
                const idsFileName = idsDiv.dataset.idsfile;

                // IDS file filter
                if (idsFileFilter && idsFileName !== idsFileFilter) {
                    idsDiv.style.display = 'none';
                    continue;
                }

                // Check all entities within this IDS
                const entityResults = idsDiv.querySelectorAll('.entity-result');
                let visibleCount = 0;

                for (let entityDiv of entityResults) {
                    let visible = true;

                    // Status filter
                    if (statusFilter && entityDiv.dataset.status !== statusFilter) {
                        visible = false;
                    }

                    // Search filter
                    if (searchText && visible) {
                        const entity = entityDiv.dataset.entity.toLowerCase();
                        const name = entityDiv.dataset.name.toLowerCase();
                        const guid = entityDiv.dataset.guid.toLowerCase();

                        if (!entity.includes(searchText) &&
                            !name.includes(searchText) &&
                            !guid.includes(searchText)) {
                            visible = false;
                        }
                    }

                    entityDiv.style.display = visible ? 'block' : 'none';
                    if (visible) visibleCount++;
                }

                // Hide IDS if no entities visible
                idsDiv.style.display = visibleCount > 0 ? 'block' : 'none';
            }
        }

        function clearFilters() {
            document.getElementById('searchFilter').value = '';
            document.getElementById('statusFilter').value = '';
            document.getElementById('specFilter').value = '';
            applyFilters();
        }

        // Export to XLSX
        document.getElementById('exportBtn').addEventListener('click', exportToXLSX);

        function exportToXLSX() {
            const wb = XLSX.utils.book_new();

            // Create a sheet for each IDS file
            for (let idsResult of validationResults) {
                const sheetData = [];

                // Header row
                sheetData.push([
                    'IFC File',
                    'Specification',
                    'Entity Type',
                    'Entity Name',
                    'GUID',
                    'Status',
                    'Validation Type',
                    'Validation Message',
                    'Details'
                ]);

                // Data rows - only include non-empty results
                for (let ifcResult of idsResult.ifcResults) {
                    // Skip if no specifications with results
                    if (!ifcResult.specificationResults || ifcResult.specificationResults.length === 0) {
                        continue;
                    }

                    for (let specResult of ifcResult.specificationResults) {
                        for (let entityResult of specResult.entityResults) {
                            for (let validation of entityResult.validations) {
                                sheetData.push([
                                    ifcResult.ifcFileName,
                                    specResult.specification,
                                    entityResult.entity,
                                    entityResult.name,
                                    entityResult.guid,
                                    entityResult.status,
                                    validation.type,
                                    validation.message,
                                    validation.details
                                ]);
                            }
                        }
                    }
                }

                // Skip this IDS if no data rows (only header)
                if (sheetData.length <= 1) {
                    continue;
                }

                // Create worksheet
                const ws = XLSX.utils.aoa_to_sheet(sheetData);

                // Set column widths
                ws['!cols'] = [
                    { wch: 25 }, // IFC File
                    { wch: 30 }, // Specification
                    { wch: 20 }, // Entity Type
                    { wch: 30 }, // Entity Name
                    { wch: 25 }, // GUID
                    { wch: 10 }, // Status
                    { wch: 15 }, // Validation Type
                    { wch: 35 }, // Validation Message
                    { wch: 50 }  // Details
                ];

                // Sanitize sheet name (Excel has restrictions)
                let sheetName = idsResult.idsTitle || idsResult.idsFileName;
                sheetName = sheetName.replace(/[:\\\/\?\*\[\]]/g, '_').substring(0, 31);

                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            }

            // Create summary sheet
            const summaryData = [];
            summaryData.push(['IDS Validation Summary']);
            summaryData.push([]);
            summaryData.push(['IDS File', 'IDS Title', 'IFC Files with Results', 'Total Validations', 'Passed', 'Failed']);

            for (let idsResult of validationResults) {
                let totalPass = 0;
                let totalFail = 0;
                let nonEmptyIfcCount = 0;

                for (let ifcResult of idsResult.ifcResults) {
                    // Only count IFC files that have specifications with results
                    if (ifcResult.specificationResults && ifcResult.specificationResults.length > 0) {
                        nonEmptyIfcCount++;
                        for (let specResult of ifcResult.specificationResults) {
                            totalPass += specResult.passCount;
                            totalFail += specResult.failCount;
                        }
                    }
                }

                // Skip this IDS if no validations
                if (totalPass + totalFail === 0) {
                    continue;
                }

                summaryData.push([
                    idsResult.idsFileName,
                    idsResult.idsTitle,
                    nonEmptyIfcCount,
                    totalPass + totalFail,
                    totalPass,
                    totalFail
                ]);
            }

            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            summaryWs['!cols'] = [
                { wch: 30 },
                { wch: 30 },
                { wch: 15 },
                { wch: 18 },
                { wch: 12 },
                { wch: 12 }
            ];

            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary', true);

            // Generate and download
            XLSX.writeFile(wb, 'ids-validation-results.xlsx');
        }

        // New validation button
        document.getElementById('newValidationBtn').addEventListener('click', () => {
            document.getElementById('resultsSection').style.display = 'none';
            document.querySelector('.upload-section').style.display = 'block';

            // Reset
            ifcFiles = [];
            idsFiles = [];
            validationResults = null;

            updateIFCFileList();
            updateIDSFileList();
            updateValidateButton();
        });
    </script>
</body>
</html>
